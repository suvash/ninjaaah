/*
-----------------------------------------------------------------------------
Filename:    OgreApp3.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (August 2010)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "MapCreate.h"

//-------------------------------------------------------------------------------------
MapCreate::MapCreate(Ogre::Root* mRoot, Ogre::SceneManager* mSceneMgr, int dim_x, int dim_y, int room_min_x, int room_min_y, int room_max_area, int door_cnt, bool furniture_enable, int desk_cnt, int chair_cnt, int shelf_cnt, int painting_cnt)
{	
	mapFinished = false;
	mRandGen = new RandGen();

	mRandGen->generateMap(dim_x,dim_y,room_min_x,room_min_y,room_max_area,door_cnt,furniture_enable,desk_cnt,chair_cnt,shelf_cnt,painting_cnt);
	//mRandGen->generateMap(dim_x,dim_y,room_min_x,room_min_y,room_max_area,1,furniture_enable,desk_cnt,chair_cnt,shelf_cnt,painting_cnt);
	//mRandGen->generateMap(27,27,14,14,196,1,furniture_enable,desk_cnt,chair_cnt,shelf_cnt,painting_cnt);
	//mRandGen->generateMap(100,100,14,14,600,2,furniture_enable,desk_cnt,chair_cnt,shelf_cnt,painting_cnt);
	Ogre::Entity* mfloorEnt;
	Ogre::Entity* mTmpEnt;
	std::vector<Ogre::Entity*> mWallEnt;
	std::vector<Ogre::Entity*> mFurnitureEnt;
	Ogre::SceneNode* mTmpNode;

	//Materials
	Ogre::MaterialPtr mat1 = Ogre::MaterialManager::getSingleton().create("FloorMat", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	Ogre::TextureUnitState* tuisTexture1 = mat1->getTechnique(0)->getPass(0)->createTextureUnitState("MRAMOR6X6.jpg");

	Ogre::MaterialPtr mat2 = Ogre::MaterialManager::getSingleton().create("WallBlue", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	Ogre::TextureUnitState* tuisTexture2 = mat2->getTechnique(0)->getPass(0)->createTextureUnitState("wallTexBlue.png");

	Ogre::MaterialPtr mat3 = Ogre::MaterialManager::getSingleton().create("WallGreen", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	Ogre::TextureUnitState* tuisTexture3 = mat3->getTechnique(0)->getPass(0)->createTextureUnitState("wallTexGreen.png");
	
	Ogre::MaterialPtr mat4 = Ogre::MaterialManager::getSingleton().create("WallPink", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	Ogre::TextureUnitState* tuisTexture4 = mat4->getTechnique(0)->getPass(0)->createTextureUnitState("wallTexPink.png");

	mfloorEnt = mSceneMgr->createEntity("floor1", "cube.mesh");
	mfloorEnt->setMaterialName("FloorMat");

	//mfloorEnt->setCastShadows(false);
	mFloorNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("FloorNode", Ogre::Vector3(dim_x/2, -0.5, dim_y/2));
	mFloorNode->attachObject(mfloorEnt);
	mFloorNode->setScale(0.01 * dim_x, 0.01, 0.01 * dim_y);
	
	int w = mRandGen->GetLongestWall();
	int wallIndex = 0;
	for(int i = 0; i < mRandGen->arena.wall_cnt; i++)
	{
		if(i != w)
		{
			mTmpEnt = mSceneMgr->createEntity("cube.mesh");
			//mTmpEnt->setCastShadows(false);
			int r = mRandGen->randInt(0,1);
			switch (r)
			{
				case 0: 
					mTmpEnt->setMaterialName("WallBlue");
					break;
				case 1: 
					mTmpEnt->setMaterialName("WallGreen");
					break;
				case 2: 
					mTmpEnt->setMaterialName("WallPink");
					break;
			}
			mWallEnt.push_back(mTmpEnt);

			mTmpNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
			mTmpNode->attachObject(mWallEnt[wallIndex]);
			wallIndex++;
			mTmpNode->setScale(0.01 * (mRandGen->arena.wall[i].dim3D.x) ,0.2, 0.01 * (mRandGen->arena.wall[i].dim3D.y));
			mTmpNode->setPosition(mRandGen->arena.wall[i].pos3D.x,10,mRandGen->arena.wall[i].pos3D.y);
			mWallNode.push_back(mTmpNode);
			mRoot->renderOneFrame();
		}
	}
	int boxIndex=0;
	for(int i = mRandGen->arena.wall[w].pos3D.x - mRandGen->arena.wall[w].dim3D.x/2; i < mRandGen->arena.wall[w].pos3D.x + mRandGen->arena.wall[w].dim3D.x/2; i++)
	{
		for(int j = mRandGen->arena.wall[w].pos3D.y - mRandGen->arena.wall[w].dim3D.y/2; j < mRandGen->arena.wall[w].pos3D.y + mRandGen->arena.wall[w].dim3D.y/2; j++)
		{
			for(float k = 0; k < 20; k=k+2)
			{
				mTmpEnt = mSceneMgr->createEntity("cube.mesh");
				int r = mRandGen->randInt(2,2);
				switch (r)
				{
				case 0: 
					//mTmpEnt = mSceneMgr->createEntity("cube.mesh");
					//mTmpEnt->setMaterialName("WallBlue");
					break;
				case 1: 
					//mTmpEnt = mSceneMgr->createEntity("cube.mesh");
					//mTmpEnt->setMaterialName("WallGreen");
					break;
				case 2: 
					//mTmpEnt = mSceneMgr->createEntity("cube.mesh");
					mTmpEnt->setMaterialName("WallPink");
					break;
				}
				//mTmpEnt->setCastShadows(false);
				mFurnitureEnt.push_back(mTmpEnt);

				mTmpNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
				mTmpNode->attachObject(mFurnitureEnt[boxIndex]);
				boxIndex++;
				mTmpNode->setScale(0.01 ,0.02, 0.01);
				
				float boxWidth = 1;//1.05;
				float boxHeight = 1;
				
				int x = i * boxWidth;
				float y = k * boxHeight;
				int z = j * boxWidth;
				
				mTmpNode->setPosition(x+0.5,y+1.0001,z+0.5);
				mFurnitureNode.push_back(mTmpNode);
				//mRoot->renderOneFrame();
			}
		}
	}
	mapFinished = true;
	map = mRandGen->arena.blackTile;
}
//-------------------------------------------------------------------------------------
MapCreate::~MapCreate(void)
{
	delete mRandGen;
}

Ogre::SceneNode* MapCreate::returnFloorNode()
{
	return mFloorNode;
}
std::vector<Ogre::SceneNode*> MapCreate::returnFurnitureNodeVec()
{
	return mFurnitureNode;
}
std::vector<Ogre::SceneNode*> MapCreate::returnWallNodeVec()
{
	return mWallNode;
}