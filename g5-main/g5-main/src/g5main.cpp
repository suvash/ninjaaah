/*
-----------------------------------------------------------------------------
Filename:    g5main.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (August 2010)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "g5main.h"
//-------------------------------------------------------------------------------------
g5main::g5main(void)
	: 
	mGuiActive(false),
	mainMenuActive(false),
	cameraFPVinUse(false),
	gameActive(false),
	mapCreateFinished(false)
{
	mCEGUI = new OgreCEGUI();
}
//-------------------------------------------------------------------------------------
g5main::~g5main(void)
{
	delete mCEGUI;
}
//-------------------------------------------------------------------------------------
void g5main::createScene(void)
{
	mGuiActive = true;
	mainMenuActive = true;
	mCEGUI->createScene();
}
//-------------------------------------------------------------------------------------
void g5main::clearScene(void)
{
	mSceneMgr->clearScene();
	mTrayMgr->hideAll();
	mTrayMgr->destroyAllWidgets();
	mRoot->removeFrameListener(this);
	mWindow->getViewport(0)->setCamera(mCamera);
	cameraFPVinUse = false;
	if (mCEGUI->extensionSettings.aiSettingsOn) delete mAnimation;
	if (mCEGUI->extensionSettings.physSettingsOn)
	{
		delete mBulletWorld;
		delete player;
	}
	delete mTrayMgr;
	gameActive = false;
	mapCreateFinished = false;
}
//-------------------------------------------------------------------------------------
void g5main::createCamera(void)
{
	// Create the camera
	mCamera = mSceneMgr->createCamera("PlayerCam");

	// Position it at 500 in Z direction
	mCamera->setPosition(30, 50, 200);
	mCamera->lookAt(25, 0, 25);
	mCamera->setNearClipDistance(0.1);

	mCameraMan = new OgreBites::SdkCameraMan(mCamera);   // create a default camera controller

	mCameraFPV = mSceneMgr->createCamera("FPVCam");
	mCamera->lookAt(Ogre::Vector3(0, 10, mCEGUI->extensionSettings.threeDSettingsArenaSizeX));
	mCameraFPV->setNearClipDistance(0.1);
	mCameraFPV->setFarClipDistance(150);
}
//-------------------------------------------------------------------------------------
void g5main::createFrameListener(void)
{
	Ogre::LogManager::getSingletonPtr()->logMessage("*** Initializing OIS ***");
	OIS::ParamList pl;
	size_t windowHnd = 0;
	std::ostringstream windowHndStr;

	mWindow->getCustomAttribute("WINDOW", &windowHnd);
	windowHndStr << windowHnd;
	pl.insert(std::make_pair(std::string("WINDOW"), windowHndStr.str()));

	mInputManager = OIS::InputManager::createInputSystem( pl );

	mKeyboard = static_cast<OIS::Keyboard*>(mInputManager->createInputObject( OIS::OISKeyboard, true ));
	mMouse = static_cast<OIS::Mouse*>(mInputManager->createInputObject( OIS::OISMouse, true ));

	mMouse->setEventCallback(this);
	mKeyboard->setEventCallback(this);

	//Set initial mouse clipping size
	windowResized(mWindow);

	//Register as a Window listener
	Ogre::WindowEventUtilities::addWindowEventListener(mWindow, this);

	mRoot->addFrameListener(this);
}
//-------------------------------------------------------------------------------------
bool g5main::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	if(mWindow->isClosed()) return false;

	if(mCEGUI->mShutDown)
	{
		if (mainMenuActive) BaseApplication::createFrameListener();
		return false;
	}
	
	if(mCEGUI->mLaunch) launch();

	if(mGuiActive)
	{
		if(mCEGUI->showMainMenu)
		{
			g5main::clearScene();
			mCEGUI->ShowMainMenu();
			mCEGUI->showMainMenu = false;
			mGuiActive = true;
			mainMenuActive = true;
			g5main::createFrameListener();
		}

		if(!mainMenuActive && !(mCEGUI->ingameMenuVisible)) mGuiActive = false;

		//Need to capture/update each device
		mKeyboard->capture();
		mMouse->capture();

		return true;
	}
	
	if (mapCreateFinished)
	{
		if (mCEGUI->extensionSettings.physSettingsOn && !mGuiActive)
		{
			// Camera Toggle
			if(cameraFPVinUse)
			{
				mKeyboard->capture();

				Ogre::Real velocity = 15.0f;

				if(mKeyboard->isKeyDown(OIS::KC_A))
				{
					player->defaultBody->setLinearVelocity(mCameraFPV->getDerivedRight().normalisedCopy() * Ogre::Vector3(-velocity, 0, -velocity));
				}
				else if(mKeyboard->isKeyDown(OIS::KC_D))
				{
					player->defaultBody->setLinearVelocity(mCameraFPV->getDerivedRight().normalisedCopy() * Ogre::Vector3(velocity, 0, velocity));
				}
				else if(mKeyboard->isKeyDown(OIS::KC_W))
				{
					player->defaultBody->setLinearVelocity(mCameraFPV->getDerivedDirection().normalisedCopy() * Ogre::Vector3(velocity,0,velocity));
				}
				else if(mKeyboard->isKeyDown(OIS::KC_S))
				{
					player->defaultBody->setLinearVelocity(mCameraFPV->getDerivedDirection().normalisedCopy() * Ogre::Vector3(-velocity, 0, -velocity));
				}
				else if(mKeyboard->isKeyDown(OIS::KC_R))
				{
					player->node->setPosition(10,0.2,10);
					player->defaultBody->setCastShadows(true);
				}
				else
				{
					player->defaultBody->setLinearVelocity(Ogre::Vector3::ZERO);
				}
				
			}
			mBulletWorld->mWorld->stepSimulation(evt.timeSinceLastFrame);
		}
		// AI
		if (mCEGUI->extensionSettings.aiSettingsOn && !mGuiActive)
		{
			
			if (!mCEGUI->extensionSettings.physSettingsOn) // IF Physics off
				gameActive = mAnimation->UpdateAnimation(evt, mSceneMgr, mCamera);
			else // else if physics on
				gameActive = mAnimation->UpdateAnimation(evt, mSceneMgr, mCameraFPV);
		}
		if (!gameActive && !mGuiActive)
		{
			mSceneMgr->setFog(Ogre::FOG_LINEAR,Ogre::ColourValue (0.4,0,0,0.8), 0.001 ,1, 100);
			mCEGUI->ShowIngameMenu(gameActive);
			mGuiActive = true;
			//gameFinished = false;
		}
		return BaseApplication::frameRenderingQueued(evt);
	}
	else return true;
}
//-------------------------------------------------------------------------------------
bool g5main::keyPressed( const OIS::KeyEvent &arg )
{
	if(mGuiActive)
	{
		mCEGUI->keyPressed(arg, gameActive);
		return true;
	}
	if (mGuiActive == false && arg.key == OIS::KC_ESCAPE)
	{
		mCEGUI->ShowIngameMenu(gameActive);
		mGuiActive = true;
		return true;
	}
	if (mCEGUI->extensionSettings.physSettingsOn != 0 && !mGuiActive)
	{
		if (arg.key == OIS::KC_B)//&& mTimeUntilNextToggle <=0){
		{
			Ogre::Vector3 position;
			Ogre::Vector3 speed;

			if(cameraFPVinUse)
			{
				position = (mCameraFPV->getDerivedPosition() + mCameraFPV->getDerivedDirection().normalisedCopy() * 10);
				speed = mCameraFPV->getDerivedDirection().normalisedCopy() * 9.0f;
			}
			else
			{
				// starting position of the box
				position = (mCamera->getDerivedPosition() + mCamera->getDerivedDirection().normalisedCopy() * 10);
				speed = mCamera->getDerivedDirection().normalisedCopy() * 9.0f;
			}
			OBBox *box = new OBBox(mSceneMgr, mBulletWorld->mWorld, position, speed, mBulletWorld->mNumEntitiesInstanced, "cube.mesh");

			mBulletWorld->mNumEntitiesInstanced++;				
			//mTimeUntilNextToggle = 0.5;

			// push the created objects to the dequese
			mBulletWorld->mShapes.push_back(box->sceneBoxShape);
			mBulletWorld->mBodies.push_back(box->defaultBody);				
			//mTimeUntilNextToggle = 0.5;
			return true;
		}
		if (arg.key == OIS::KC_C)
		{
			//Toggle the camera ...
			if(cameraFPVinUse)
			{
				cameraFPVinUse = false;
				mWindow->getViewport(0)->setCamera(mCamera);
				mCamera->setPosition(mCameraPos);
				mCamera->setOrientation(mCameraOrt);
			}
			else
			{
				cameraFPVinUse = true;
				mWindow->getViewport(0)->setCamera(mCameraFPV);
				mCameraPos = mCamera->getPosition();
				mCameraOrt = mCamera->getOrientation();
			}
			return true;
		}
	}
	return BaseApplication::keyPressed(arg);
}
//-------------------------------------------------------------------------------------
bool g5main::keyReleased( const OIS::KeyEvent &arg )
{
	if(mGuiActive)
	{
		if (mCEGUI->ingameMenuVisible) mCameraMan->injectKeyUp(arg);
		mCEGUI->keyReleased(arg);
		return true;
	}	
	return BaseApplication::keyReleased(arg);
}
//-------------------------------------------------------------------------------------
bool g5main::mouseMoved( const OIS::MouseEvent &arg )
{
	if(mGuiActive)
	{
		mCEGUI->mouseMoved(arg);
		return true;
	}
	if(cameraFPVinUse)
	{
		mCameraFPV->yaw(Ogre::Degree(-arg.state.X.rel * 0.25f));
		mCameraFPV->pitch(Ogre::Degree(-arg.state.Y.rel * 0.25f));
		return true;
	}
	return BaseApplication::mouseMoved(arg);
}
//-------------------------------------------------------------------------------------
bool g5main::mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	if(mGuiActive)
	{
		mCEGUI->mousePressed(arg,id);
		return true;
	}
	return BaseApplication::mousePressed(arg,id);
}
//-------------------------------------------------------------------------------------
bool g5main::mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	if(mGuiActive)
	{
		mCEGUI->mouseReleased(arg,id);
		return true;
	}
	return BaseApplication::mouseReleased(arg,id);
}
//-------------------------------------------------------------------------------------
void g5main::createGrassMesh()
{
	//declare all of our grass variables
	const float width = 25.0f;
	const float height = 40.0f;

	Ogre::ManualObject grass("GrassObject");

	Ogre::Vector3 vec(width / 2, 0, 0);
	Ogre::Quaternion rot;
	rot.FromAngleAxis(Ogre::Degree(60), Ogre::Vector3::UNIT_Y);

	//start defining our manual object
	grass.begin("Examples/GrassBlades", Ogre::RenderOperation::OT_TRIANGLE_LIST);

	//define the 4 vertices of our quad and set to the texture coordinates
	for(int i = 0; i < 3; ++i)
	{
		grass.position(-vec.x, height, -vec.z);
		grass.textureCoord(0, 0);

		grass.position(vec.x, height, vec.z);
		grass.textureCoord(1, 0);

		grass.position(-vec.x, 0, -vec.z);
		grass.textureCoord(0, 1);

		grass.position(vec.x, 0, vec.z);
		grass.textureCoord(1, 1);

		int offset = i * 4;

		grass.triangle(offset, offset + 3, offset + 1);
		grass.triangle(offset, offset + 2, offset + 3);

		//rotate the next quad
		vec = rot * vec;
	}
	grass.end();

	//create an actual mesh out of this object
	grass.convertToMesh("GrassBladesMesh");
}
//-------------------------------------------------------------------------------------
bool g5main::launch()
{
	mCEGUI->mLaunch = false;
	mGuiActive = false;
	mainMenuActive = false;
	gameActive = true;
	// Set ambient light
	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));
	// Create a light
	Ogre::Light* l = mSceneMgr->createLight("MainLight");
	l->setPosition(20,80,50);
	// Camera
	Ogre::Vector3 camLookAt = Ogre::Vector3(mCEGUI->extensionSettings.threeDSettingsArenaSizeX/2, 0, mCEGUI->extensionSettings.threeDSettingsArenaSizeY/2);
	int camHeight;
	if (mCEGUI->extensionSettings.threeDSettingsArenaSizeX > mCEGUI->extensionSettings.threeDSettingsArenaSizeY) camHeight = mCEGUI->extensionSettings.threeDSettingsArenaSizeX;
	else camHeight = mCEGUI->extensionSettings.threeDSettingsArenaSizeY;
	mCamera->setPosition(Ogre::Vector3(0, 50 + camHeight/4, 0) + (-0.5f) * camLookAt);
	mCamera->lookAt(camLookAt);
	mCamera->setNearClipDistance(0.1);
	// Enable shadows
	mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);
	// Enable Sky Dome
	mSceneMgr->setSkyDome(true, "Examples/CloudySky", 5, 8);
	// Disable fog
	mSceneMgr->setFog(Ogre::FOG_NONE);
	// Create Grass
	createGrassMesh();
	Ogre::Plane plane;
	plane.normal = Ogre::Vector3::UNIT_Y;
	plane.d = 0;
	Ogre::MeshManager::getSingleton().createPlane("plane", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plane, 10000.0f, 10000.0f, 10, 10, true, 1, 50.0f, 50.0f, Ogre::Vector3::UNIT_Z);
	Ogre::Entity* planeEnt = mSceneMgr->createEntity("floor","plane");
	planeEnt->setMaterialName("Examples/GrassFloor");
	planeEnt->setCastShadows(false);
	grassNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("grassNode",Ogre::Vector3(0,-1,0));
	grassNode->attachObject(planeEnt);
	Ogre::Entity* grass = mSceneMgr->createEntity("grass", "GrassBladesMesh");
	Ogre::StaticGeometry* sg = mSceneMgr->createStaticGeometry("GrassArea");
	const int size = mCEGUI->extensionSettings.threeDSettingsArenaSizeX+600;
	const int amount = 6;
	sg->setRegionDimensions(Ogre::Vector3(size, size, size));
	sg->setOrigin(Ogre::Vector3(-size/2, 0, -size/2));
	for(int x = -size / 2; x < size /2; x += (size/amount))
	{
		for(int z = -size / 2; z < size / 2; z += (size/amount))
		{
			if ((x < -50 || x > mCEGUI->extensionSettings.threeDSettingsArenaSizeX + 50 ) && (z < -50 || z > mCEGUI->extensionSettings.threeDSettingsArenaSizeY + 50 ))
			{
				Ogre::Real r = 50;//size / float(amount / 2);
				Ogre::Vector3 pos(x + Ogre::Math::RangeRandom(-r, r), 0, z + Ogre::Math::RangeRandom(-r, r));
				Ogre::Vector3 scale(1, Ogre::Math::RangeRandom(0.9f, 1.1f), 1);
				Ogre::Quaternion orientation;


				orientation.FromAngleAxis(Ogre::Degree(Ogre::Math::RangeRandom(0, 359)), Ogre::Vector3::UNIT_Y);

				sg->addEntity(grass, pos, orientation, scale);
			}
		}
		sg->build();
	}
	// Grass Stop

	BaseApplication::createFrameListener();
	if (mCEGUI->extensionSettings.threeDSettingsActive == true)
	{
		mMapCreate = new MapCreate(mRoot, mSceneMgr, mCEGUI->extensionSettings.threeDSettingsArenaSizeX, mCEGUI->extensionSettings.threeDSettingsArenaSizeY, 14, 14 , mCEGUI->extensionSettings.threeDsettingsMaxRoomSize, mCEGUI->extensionSettings.threeDsettingsDoorCnt, mCEGUI->extensionSettings.threeDsettingsFurnitureEn);
	}
	else mMapCreate = new MapCreate(mRoot, mSceneMgr);
	mapCreateFinished = mMapCreate->mapFinished;

	// AI
	if (mCEGUI->extensionSettings.aiSettingsOn)
	{
		if (!mCEGUI->extensionSettings.physSettingsOn) // IF Physics off
		{
			if(mCEGUI->extensionSettings.aiSettingsCustomOn)
			{
				mAnimation = new Animation(mMapCreate->map, mSceneMgr, mCamera, mCEGUI->extensionSettings.aiSettingsSFRVal, mCEGUI->extensionSettings.aiSettingsFFRVal, mCEGUI->extensionSettings.aiSettingsSFDVal, mCEGUI->extensionSettings.aiSettingsFFDVal, mCEGUI->extensionSettings.aiSettingsDFDVal, mCEGUI->extensionSettings.aiSettingsAISVal);
			}
			else
			{
				mAnimation = new Animation(mMapCreate->map, mSceneMgr, mCamera);
			}
		}
		else // else if physics on
		{
			if(mCEGUI->extensionSettings.aiSettingsCustomOn)
			{
				mAnimation = new Animation(mMapCreate->map, mSceneMgr, mCameraFPV, mCEGUI->extensionSettings.aiSettingsSFRVal, mCEGUI->extensionSettings.aiSettingsFFRVal, mCEGUI->extensionSettings.aiSettingsSFDVal, mCEGUI->extensionSettings.aiSettingsFFDVal, mCEGUI->extensionSettings.aiSettingsDFDVal, mCEGUI->extensionSettings.aiSettingsAISVal);
			}
			else
			{
				mAnimation = new Animation(mMapCreate->map, mSceneMgr, mCameraFPV);
			}
		}
	}

	if (mCEGUI->extensionSettings.physSettingsOn)
	{
		//Create the Physics world
		mBulletWorld = new BulletInitWorld(mSceneMgr,
										   mMapCreate->returnFloorNode(),
										   mMapCreate->returnWallNodeVec(),
										   mCEGUI->extensionSettings.threeDSettingsArenaSizeX,
										   mCEGUI->extensionSettings.threeDSettingsArenaSizeY,
										   mCEGUI->extensionSettings.threeDSettingsArenaSizeX);

		// starting position of the player
		Ogre::Vector3 position = Ogre::Vector3(10, 0.2, 10);//(mCamera->getDerivedPosition() + mCamera->getDerivedDirection().normalisedCopy() * 10);
		Ogre::Vector3 speed = Ogre::Vector3(0, 0, 0);//mCamera->getDerivedDirection().normalisedCopy() * 9.0f;


		player = new OBPlayer(mSceneMgr, mBulletWorld->mWorld, position, speed, mBulletWorld->mNumEntitiesInstanced, "ogrehead.mesh");
		player->defaultBody->disableDeactivation();

		//Add the body count and add to deque
		mBulletWorld->mNumEntitiesInstanced++;				
		// push the created objects to the deque
		mBulletWorld->mShapes.push_back(player->sceneBoxShape);
		mBulletWorld->mBodies.push_back(player->defaultBody);				
		//mTimeUntilNextToggle = 0.5;

		//Adding camera to the box node
		player->node->attachObject(mCameraFPV);
		mCameraFPV->setPosition(player->node->getPosition()*Ogre::Vector3(0,60,0));

		cameraFPVinUse = true;
		mWindow->getViewport(0)->setCamera(mCameraFPV);
		mCameraPos = mCamera->getPosition();
		mCameraOrt = mCamera->getOrientation();
	}

	delete mMapCreate;
	return true;
}
//-------------------------------------------------------------------------------------
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        g5main app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
